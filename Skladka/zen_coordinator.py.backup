#\\!/usr/bin/env python3
"""
Enhanced Zen MCP Coordinator with HTTP and MCP support
Fixes GET endpoint errors and provides comprehensive tool routing
Updated to use Memory MCP server on port 8007
Fixed Git MCP integration to use correct API endpoints
"""
import json
import http.server
import socketserver
import urllib.request
import urllib.parse
import subprocess
import sys
import os

class ZenHandler(http.server.BaseHTTPRequestHandler):
    def log_message(self, format, *args):
        # Suppress default logging
        pass
    
    def do_GET(self):
        """Handle GET requests"""
        if self.path == '/health':
            self.send_response(200)
            self.send_header('Content-Type', 'application/json')
            self.end_headers()
            health_data = {
                "status": "healthy",
                "service": "Zen MCP Coordinator",
                "version": "2.3",
                "tools_available": 12,
                "endpoints": ["/health", "/mcp", "/status", "/tools"]
            }
            self.wfile.write(json.dumps(health_data).encode())
            
        elif self.path == '/status':
            self.send_response(200)
            self.send_header('Content-Type', 'application/json')
            self.end_headers()
            status_data = {
                "coordinator": "active",
                "mcp_services": {
                    "filesystem": "http://192.168.0.58:8001",
                    "git": "http://192.168.0.58:8002", 
                    "terminal": "http://192.168.0.58:8003",
                    "database": "http://192.168.0.58:8004",
                    "research": "http://192.168.0.58:8005",
                    "webbridge": "http://192.168.0.58:8006",
                    "memory": "http://192.168.0.58:8007",
                    "gmail": "stdio",
                    "webm_transcriber": "http://192.168.0.58:8008"
                }
            }
            self.wfile.write(json.dumps(status_data).encode())
            
        elif self.path == '/tools':
            self.send_response(200)
            self.send_header('Content-Type', 'application/json')
            self.end_headers()
            tools_data = {
                "available_tools": [
                    "execute_command", "list_files", "read_file",
                    "store_memory", "search_memories",
                    "search_emails", "send_email", 
                    "transcribe_audio", "transcribe_url",
                    "git_execute", "create_ai_project", "inject_forai_headers"
                ],
                "total": 12
            }
            self.wfile.write(json.dumps(tools_data).encode())
            
        else:
            self.send_response(404)
            self.send_header('Content-Type', 'application/json')
            self.end_headers()
            error_data = {"error": "Endpoint not found", "available": ["/health", "/mcp", "/status", "/tools"]}
            self.wfile.write(json.dumps(error_data).encode())
    
    def do_POST(self):
        """Handle POST requests"""
        if self.path == '/mcp':
            content_length = int(self.headers.get('Content-Length', 0))
            post_data = self.rfile.read(content_length)
            
            try:
                data = json.loads(post_data.decode('utf-8'))
                tool_name = data.get('tool', '')
                tool_args = data.get('arguments', {})
                
                # Route to appropriate service
                result = self.route_tool_request(tool_name, tool_args)
                
                self.send_response(200)
                self.send_header('Content-Type', 'application/json')
                self.end_headers()
                self.wfile.write(json.dumps(result).encode())
                
            except Exception as e:
                self.send_response(500)
                self.send_header('Content-Type', 'application/json')
                self.end_headers()
                error_result = {"error": f"Request processing failed: {str(e)}"}
                self.wfile.write(json.dumps(error_result).encode())
        else:
            self.send_response(404)
            self.send_header('Content-Type', 'application/json')
            self.end_headers()
            error_data = {"error": "POST endpoint not found"}
            self.wfile.write(json.dumps(error_data).encode())
    
    def route_tool_request(self, tool_name, tool_args):
        """Route tool requests to appropriate services"""
        try:
            # Filesystem tools
            if tool_name == 'list_files':
                path = tool_args.get('path', '/')
                url = f'http://192.168.0.58:8001/files/{urllib.parse.quote(path)}'
                return self.call_http_service(url)
                
            elif tool_name == 'read_file':
                path = tool_args.get('path', '')
                url = f'http://192.168.0.58:8001/file/{urllib.parse.quote(path)}'
                return self.call_http_service(url)
            
            # Terminal tools
            elif tool_name == 'execute_command':
                command = tool_args.get('command', '')
                payload = {'command': command, 'user_id': 'mcp'}
                url = 'http://192.168.0.58:8003/command'
                return self.call_http_service_post(url, payload)
            
            # Git tools - FIXED to use correct Git MCP API endpoints
            elif tool_name == 'git_execute':
                command = tool_args.get('command', '')
                working_dir = tool_args.get('working_dir', '/tmp')
                
                # Parse git command and route to appropriate endpoint
                return self.handle_git_command(command, working_dir)
            
            # Memory tools (Updated to use HTTP Memory MCP server on port 8007)
            elif tool_name == 'store_memory':
                content = tool_args.get('content', '')
                metadata = tool_args.get('metadata', {})
                payload = {'content': content, 'metadata': metadata}
                url = 'http://192.168.0.58:8007/memory/store'
                return self.call_http_service_post(url, payload)
            
            elif tool_name == 'search_memories':
                query = tool_args.get('query', '')
                limit = tool_args.get('limit', 10)
                payload = {'query': query, 'limit': limit}
                url = 'http://192.168.0.58:8007/memory/search'
                return self.call_http_service_post(url, payload)
            
            # Email tools (Gmail MCP)
            elif tool_name in ['search_emails', 'send_email']:
                return self.call_stdio_service('gmail', tool_name, tool_args)
            
            # Transcription tools (WEBM Transcriber)
            elif tool_name == 'transcribe_audio':
                audio_data = tool_args.get('audio_data', '')
                format_type = tool_args.get('format', 'webm')
                payload = {'audio_data': audio_data, 'format': format_type}
                url = 'http://192.168.0.58:8008/transcribe/audio'
                return self.call_http_service_post(url, payload)
            
            elif tool_name == 'transcribe_url':
                audio_url = tool_args.get('url', '')
                payload = {'url': audio_url}
                url = 'http://192.168.0.58:8008/transcribe/url'
                return self.call_http_service_post(url, payload)
            
            # Development tools
            elif tool_name == 'create_ai_project':
                project_name = tool_args.get('project_name', '')
                description = tool_args.get('description', '')
                return self.call_plandex_tool(project_name, description)
            
            elif tool_name == 'inject_forai_headers':
                file_path = tool_args.get('file_path', '')
                project_name = tool_args.get('project_name', '')
                purpose = tool_args.get('purpose', '')
                return self.call_forai_tool(file_path, project_name, purpose)
            
            else:
                return {"error": f"Unknown tool: {tool_name}"}
                
        except Exception as e:
            return {"error": f"Tool routing failed: {str(e)}"}
    
    def handle_git_command(self, command, working_dir):
        """Handle git commands using the correct Git MCP API endpoints"""
        try:
            # Normalize the working directory path for URL encoding
            encoded_path = urllib.parse.quote(working_dir)
            
            # Parse git command and route to appropriate endpoint
            if 'status' in command.lower():
                url = f'http://192.168.0.58:8002/git/{encoded_path}/status'
                return self.call_http_service(url)
                
            elif 'log' in command.lower():
                # Extract limit if specified (default: 5)
                limit = 5
                if '--oneline' in command or '-n' in command:
                    # Try to extract number after -n
                    parts = command.split()
                    for i, part in enumerate(parts):
                        if part == '-n' and i + 1 < len(parts):
                            try:
                                limit = int(parts[i + 1])
                            except ValueError:
                                pass
                            break
                        elif part.startswith('-n'):
                            try:
                                limit = int(part[2:])
                            except ValueError:
                                pass
                            break
                
                url = f'http://192.168.0.58:8002/git/{encoded_path}/log?limit={limit}'
                return self.call_http_service(url)
                
            elif 'diff' in command.lower():
                url = f'http://192.168.0.58:8002/git/{encoded_path}/diff'
                return self.call_http_service(url)
                
            else:
                # For other git commands, return a helpful message
                return {
                    "error": f"Git command '{command}' not supported by Git MCP API",
                    "supported_commands": [
                        "git status - use git status",
                        "git log - use git log or git log -n <number>", 
                        "git diff - use git diff"
                    ],
                    "available_endpoints": [
                        f"GET /git/{working_dir}/status",
                        f"GET /git/{working_dir}/log",
                        f"GET /git/{working_dir}/diff"
                    ]
                }
                
        except Exception as e:
            return {"error": f"Git command handling failed: {str(e)}"}
    
    def call_http_service(self, url):
        """Call HTTP service with GET"""
        try:
            with urllib.request.urlopen(url, timeout=10) as response:
                return json.loads(response.read().decode())
        except urllib.error.HTTPError as e:
            try:
                # Parse the JSON error response from HTTP errors (404, 500, etc.)
                error_response = json.loads(e.read().decode())
                return error_response
            except (json.JSONDecodeError, UnicodeDecodeError):
                # Fallback if the error response isn't valid JSON
                if e.code == 404:
                    return {"error": "Resource not found", "status_code": 404}
                elif e.code == 500:
                    return {"error": "Internal server error", "status_code": 500}
                else:
                    return {"error": f"HTTP {e.code}: {e.reason}", "status_code": e.code}
        except Exception as e:
            return {"error": f"HTTP service error: {str(e)}"}
    
    def call_http_service_post(self, url, payload):
        """Call HTTP service with POST and JSON payload"""
        try:
            data = json.dumps(payload).encode('utf-8')
            req = urllib.request.Request(url, data=data)
            req.add_header('Content-Type', 'application/json')
            
            with urllib.request.urlopen(req, timeout=30) as response:
                return json.loads(response.read().decode())
        except urllib.error.HTTPError as e:
            try:
                # Parse the JSON error response from HTTP errors (404, 500, etc.)
                error_response = json.loads(e.read().decode())
                return error_response
            except (json.JSONDecodeError, UnicodeDecodeError):
                # Fallback if the error response isn't valid JSON
                if e.code == 404:
                    return {"error": "Resource not found", "status_code": 404}
                elif e.code == 500:
                    return {"error": "Internal server error", "status_code": 500}
                else:
                    return {"error": f"HTTP {e.code}: {e.reason}", "status_code": e.code}
        except Exception as e:
            return {"error": f"HTTP POST service error: {str(e)}"}
    
    def call_stdio_service(self, service_name, tool_name, tool_args):
        """Call STDIO-based MCP service using subprocess"""
        try:
            # Prepare MCP request
            mcp_request = {
                "jsonrpc": "2.0",
                "id": 1,
                "method": "tools/call",
                "params": {
                    "name": tool_name,
                    "arguments": tool_args
                }
            }
            
            # Determine the command based on service
            if service_name == 'gmail':
                cmd = ['python3', '-m', 'mcp_gmail']
            else:
                return {"error": f"Unknown STDIO service: {service_name}"}
            
            # Execute the MCP service
            process = subprocess.Popen(
                cmd,
                stdin=subprocess.PIPE,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )
            
            # Send the request
            stdout, stderr = process.communicate(input=json.dumps(mcp_request), timeout=30)
            
            if process.returncode == 0:
                try:
                    response = json.loads(stdout)
                    return response.get('result', {"error": "No result in response"})
                except json.JSONDecodeError:
                    return {"error": f"Invalid JSON response from {service_name}: {stdout}"} 
            else:
                return {"error": f"{service_name} service error: {stderr}"}
                
        except subprocess.TimeoutExpired:
            process.kill()
            return {"error": f"{service_name} service timeout"}
        except Exception as e:
            return {"error": f"STDIO service error: {str(e)}"}
    
    def call_plandex_tool(self, project_name, description):
        """Call Plandex tool with robust error handling and retry logic"""
        import time
        import shutil
        
        # First check if plandex is installed
        if not shutil.which('plandex'):
            return {
                "error": "Plandex not installed", 
                "suggestion": "Install with: curl -sL https://plandex.ai/install.sh | bash"
            }
        
        # Try multiple times with increasing timeout
        max_attempts = 3
        base_timeout = 10  # Increased from 5 to 10 seconds
        
        for attempt in range(max_attempts):
            try:
                timeout = base_timeout + (attempt * 5)  # 10, 15, 20 seconds
                
                # Run plandex version command
                result = subprocess.run(
                    ['plandex', 'version'], 
                    capture_output=True, 
                    text=True, 
                    timeout=timeout,
                    env=dict(os.environ, PLANDEX_DEBUG="false")  # Disable debug output
                )
                
                if result.returncode == 0:
                    version = result.stdout.strip()
                    return {
                        "success": True,
                        "project_name": project_name,
                        "description": description,
                        "plandex_version": version,
                        "status": "Project planning ready",
                        "attempt": attempt + 1,
                        "timeout_used": timeout
                    }
                else:
                    # Log the error for debugging
                    error_msg = result.stderr.strip() if result.stderr else "Unknown plandex error"
                    if attempt == max_attempts - 1:  # Last attempt
                        return {
                            "error": f"Plandex command failed after {max_attempts} attempts",
                            "last_error": error_msg,
                            "returncode": result.returncode
                        }
                    # Wait before retry
                    time.sleep(1)
                    
            except subprocess.TimeoutExpired:
                if attempt == max_attempts - 1:  # Last attempt
                    return {
                        "error": f"Plandex command timed out after {max_attempts} attempts",
                        "last_timeout": timeout,
                        "suggestion": "System may be under heavy load"
                    }
                # Wait before retry
                time.sleep(2)
                
            except FileNotFoundError:
                return {
                    "error": "Plandex executable not found",
                    "suggestion": "Install with: curl -sL https://plandex.ai/install.sh | bash"
                }
                
            except Exception as e:
                if attempt == max_attempts - 1:  # Last attempt
                    return {
                        "error": f"Plandex error after {max_attempts} attempts: {str(e)}",
                        "type": type(e).__name__
                    }
                # Wait before retry
                time.sleep(1)
        
        # Should never reach here, but just in case
        return {"error": "Unexpected error in plandex tool"}
    
    def call_forai_tool(self, file_path, project_name, purpose):
        """Call FORAI injector tool"""
        try:
            result = subprocess.run([
                'python3', '/home/milhy777/forai_injector.py',
                file_path, project_name, purpose
            ], capture_output=True, text=True, timeout=10)
            
            if result.returncode == 0:
                return {
                    "success": True,
                    "file_path": file_path,
                    "project_name": project_name,
                    "purpose": purpose,
                    "message": "FORAI headers injected successfully"
                }
            else:
                return {"error": f"FORAI injection failed: {result.stderr}"}
        except Exception as e:
            return {"error": f"FORAI error: {str(e)}"}

def main():
    """Start the enhanced Zen Coordinator"""
    port = 8020
    print(f"Starting Enhanced Zen MCP Coordinator on port {port}...")
    print("Available endpoints:")
    print("  GET  /health - Health check")
    print("  GET  /status - Service status")
    print("  GET  /tools  - Available tools")
    print("  POST /mcp    - Tool execution")
    print("\nGit MCP Integration:")
    print("  Supports: git status, git log, git diff")
    print("  Uses Git MCP API endpoints on port 8002")
    
    # Enable socket reuse to avoid "Address already in use" error
    socketserver.TCPServer.allow_reuse_address = True
    with socketserver.TCPServer(('', port), ZenHandler) as httpd:
        print(f"Enhanced Zen Coordinator serving on port {port}")
        httpd.serve_forever()

if __name__ == "__main__":
    main()
